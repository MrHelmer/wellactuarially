<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive KNN Classification Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
</head>
<body>
    <header>
        <h1>K-Nearest Neighbors</h1>
        <p class="subtitle">An Interactive Classification Algorithm Demo</p>
    </header>

    <div id="canvasContainer"></div>

    <div id="controls">
        <div class="instructions">
            <strong>Click anywhere</strong> on the canvas to place a test point and watch the KNN algorithm classify it in real-time!
        </div>

        <div class="control-group">
            <label>
                K Value (Number of Neighbors)
                <span class="value-display" id="kValue">3</span>
            </label>
            <input type="range" id="kSlider" min="1" max="9" value="3" step="2">
        </div>

        <div class="control-group">
            <button id="resetBtn">Reset & Generate New Data</button>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-symbol" style="background: #0173B2; border-color: #0173B2; border-radius: 50%;"></div>
                <span>Class A</span>
            </div>
            <div class="legend-item">
                <div class="legend-symbol" style="background: #DE8F05; border-color: #DE8F05;"></div>
                <span>Class B</span>
            </div>
            <div class="legend-item">
                <div class="legend-symbol" style="background: #029E73; border-color: #029E73; clip-path: polygon(50% 0%, 100% 100%, 0% 100%);"></div>
                <span>Class C</span>
            </div>
        </div>
    </div>

    <script>
        // Colorblind-friendly palette from Wong (2011) - verified for deuteranopia and protanopia
        const COLORS = {
            blue: '#0173B2',      // Class A - Circle
            orange: '#DE8F05',    // Class B - Square
            green: '#029E73'      // Class C - Triangle
        };

        let dataPoints = [];
        let k = 3;
        let animatingPoint = null;
        let animationRadius = 0;
        let nearestNeighbors = [];
        let classificationResult = null;
        const ANIMATION_SPEED = 3;
        let pulseOffset = 0; // For pulsing animation

        function setup() {
            let canvas = createCanvas(800, 600);
            canvas.parent('canvasContainer');
            generateData();
            
            // Setup controls
            document.getElementById('kSlider').addEventListener('input', (e) => {
                k = parseInt(e.target.value);
                document.getElementById('kValue').textContent = k;
                if (animatingPoint) {
                    animatingPoint = null;
                }
            });
            
            document.getElementById('resetBtn').addEventListener('click', () => {
                generateData();
                animatingPoint = null;
                animationRadius = 0;
                nearestNeighbors = [];
                classificationResult = null;
            });
        }

        function generateData() {
            dataPoints = [];
            
            // Class A - Moved up and to the left, but still distinct
            for (let i = 0; i < 30; i++) {
                dataPoints.push({
                    x: random(400, 650),  // Moved left from 500-750 to 400-650
                    y: random(50, 300),   // Moved up from 150-400 to 50-300
                    class: 'A',
                    color: COLORS.blue,
                    shape: 'circle'
                });
            }
            
            // Class B - Centered around (220, 250) with large spread - moved up from 300
            for (let i = 0; i < 30; i++) {
                let x = randomGaussian(220, 80);
                let y = randomGaussian(250, 80);
                dataPoints.push({
                    x: constrain(x, 50, 450),
                    y: constrain(y, 80, 500),
                    class: 'B',
                    color: COLORS.orange,
                    shape: 'square'
                });
            }
            
            // Class C - Centered around (240, 370) - overlapping with B but more separated
            for (let i = 0; i < 30; i++) {
                let x = randomGaussian(240, 75);
                let y = randomGaussian(370, 75);
                dataPoints.push({
                    x: constrain(x, 50, 450),
                    y: constrain(y, 200, 550),
                    class: 'C',
                    color: COLORS.green,
                    shape: 'triangle'
                });
            }
        }

        function draw() {
            // Check for dark mode
            let isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            background(isDarkMode ? 19 : 255, isDarkMode ? 21 : 255, isDarkMode ? 23 : 255);
            
            // Draw grid
            stroke(isDarkMode ? 50 : 230, isDarkMode ? 50 : 230, isDarkMode ? 50 : 230);
            strokeWeight(1);
            for (let i = 0; i < width; i += 50) {
                line(i, 0, i, height);
            }
            for (let i = 0; i < height; i += 50) {
                line(0, i, width, i);
            }
            
            // Draw quadrant lines
            stroke(isDarkMode ? 80 : 200, isDarkMode ? 80 : 200, isDarkMode ? 80 : 200);
            strokeWeight(1.5);
            line(width/2, 0, width/2, height);
            line(0, height/2, width, height/2);
            
            // Draw all data points
            for (let point of dataPoints) {
                drawPoint(point.x, point.y, point.shape, point.color, 10);
            }
            
            // Animate KNN search if a point was clicked
            if (animatingPoint) {
                animateKNN();
            }
        }

        function drawPoint(x, y, shape, color, size) {
            fill(color);
            stroke(color);
            strokeWeight(2);
            
            if (shape === 'circle') {
                ellipse(x, y, size, size);
            } else if (shape === 'square') {
                rectMode(CENTER);
                rect(x, y, size, size);
            } else if (shape === 'triangle') {
                let h = size;
                triangle(x, y - h/2, x - h/2, y + h/2, x + h/2, y + h/2);
            }
        }

        function animateKNN() {
            // Update pulse for animation - doubled speed from 0.05 to 0.1
            pulseOffset += 0.1;
            let pulse = sin(pulseOffset) * 0.5 + 0.5; // Oscillates between 0 and 1
            
            // Find points within current radius
            let pointsInRadius = [];
            for (let point of dataPoints) {
                let d = dist(animatingPoint.x, animatingPoint.y, point.x, point.y);
                if (d <= animationRadius) {
                    pointsInRadius.push({ point, distance: d });
                }
            }
            
            // Sort by distance and take k nearest
            pointsInRadius.sort((a, b) => a.distance - b.distance);
            nearestNeighbors = pointsInRadius.slice(0, k);
            
            // Only continue expanding if we haven't found k neighbors yet
            let hasKNeighbors = nearestNeighbors.length >= k;
            
            // Draw expanding circle (only if still searching)
            if (!hasKNeighbors) {
                noFill();
                stroke(150, 150, 150, 100);
                strokeWeight(2);
                ellipse(animatingPoint.x, animatingPoint.y, animationRadius * 2, animationRadius * 2);
            } else {
                // Draw static circle at final radius when k neighbors found
                noFill();
                stroke(150, 150, 150, 150);
                strokeWeight(2);
                let maxDist = nearestNeighbors[nearestNeighbors.length - 1].distance;
                ellipse(animatingPoint.x, animatingPoint.y, maxDist * 2, maxDist * 2);
            }
            
            // Check if we have k neighbors for voting
            if (hasKNeighbors) {
                // Count votes
                let votes = { 'A': 0, 'B': 0, 'C': 0 };
                let classSums = { 'A': 0, 'B': 0, 'C': 0 };
                
                for (let neighbor of nearestNeighbors) {
                    votes[neighbor.point.class]++;
                    classSums[neighbor.point.class] += neighbor.distance;
                }
                
                // Determine winner - if tied, use sum of distances (smaller is better)
                let maxVotes = Math.max(votes.A, votes.B, votes.C);
                let tiedClasses = Object.keys(votes).filter(key => votes[key] === maxVotes);
                
                let winner;
                let isTied = tiedClasses.length > 1;
                
                if (isTied) {
                    // Tie-breaking: use class with smallest sum of distances
                    winner = tiedClasses.reduce((best, current) => 
                        classSums[current] < classSums[best] ? current : best
                    );
                } else {
                    winner = tiedClasses[0];
                }
                
                // Draw distance lines if there's a tie
                if (isTied) {
                    for (let neighbor of nearestNeighbors) {
                        // Determine if this class won the tie-breaker
                        let isWinningClass = neighbor.point.class === winner;
                        
                        // Draw line
                        if (isWinningClass) {
                            stroke(neighbor.point.color);
                            strokeWeight(1.5);
                        } else {
                            stroke(150, 150, 150, 120);
                            strokeWeight(1);
                        }
                        line(animatingPoint.x, animatingPoint.y, neighbor.point.x, neighbor.point.y);
                        
                        // Draw distance label at midpoint
                        let midX = (animatingPoint.x + neighbor.point.x) / 2;
                        let midY = (animatingPoint.y + neighbor.point.y) / 2;
                        
                        // Calculate slight offset perpendicular to line for label positioning
                        let angle = atan2(neighbor.point.y - animatingPoint.y, neighbor.point.x - animatingPoint.x);
                        let offsetX = cos(angle + PI/2) * 8;
                        let offsetY = sin(angle + PI/2) * 8;
                        
                        // Draw small background for distance text
                        textSize(9);
                        textFont('Bree Serif');
                        let distText = neighbor.distance.toFixed(0);
                        let txtW = textWidth(distText);
                        
                        fill(255, 255, 255, 200);
                        noStroke();
                        rectMode(CENTER);
                        rect(midX + offsetX, midY + offsetY, txtW + 6, 14, 2);
                        
                        // Draw distance text
                        if (isWinningClass) {
                            fill(neighbor.point.color);
                        } else {
                            fill(100, 100, 100, 180);
                        }
                        textAlign(CENTER, CENTER);
                        text(distText, midX + offsetX, midY + offsetY);
                    }
                }
                
                // Get color and shape for winner
                let resultColor, resultShape;
                if (winner === 'A') {
                    resultColor = COLORS.blue;
                    resultShape = 'circle';
                } else if (winner === 'B') {
                    resultColor = COLORS.orange;
                    resultShape = 'square';
                } else {
                    resultColor = COLORS.green;
                    resultShape = 'triangle';
                }
                
                // Draw classified test point
                drawPoint(animatingPoint.x, animatingPoint.y, resultShape, resultColor, 16);
            }
            
            // Highlight nearest neighbors with pulsing glow effect - draw BEHIND the original points
            for (let neighbor of nearestNeighbors) {
                let col = color(neighbor.point.color);
                
                // Draw multiple layers of increasing size and decreasing opacity for glow effect
                // Use pulse to gently vary the size and opacity
                // Shifted range: pulse goes 0-1, we map it to 0.75-1.2 for higher minimum
                let pulseRange = 0.75 + (pulse * 0.45); // Oscillates between 0.75 and 1.2
                
                for (let i = 2; i >= 0; i--) {
                    let baseSize = 14 + (i * 2.5);
                    let glowSize = baseSize * pulseRange; // Apply pulse to entire size
                    let baseAlpha = 40 - (i * 10);
                    let glowAlpha = baseAlpha * pulseRange; // Apply pulse to opacity too
                    col.setAlpha(glowAlpha);
                    fill(col);
                    noStroke();
                    
                    if (neighbor.point.shape === 'circle') {
                        ellipse(neighbor.point.x, neighbor.point.y, glowSize, glowSize);
                    } else if (neighbor.point.shape === 'square') {
                        rectMode(CENTER);
                        rect(neighbor.point.x, neighbor.point.y, glowSize, glowSize);
                    } else if (neighbor.point.shape === 'triangle') {
                        let h = glowSize;
                        triangle(
                            neighbor.point.x, neighbor.point.y - h/2,
                            neighbor.point.x - h/2, neighbor.point.y + h/2,
                            neighbor.point.x + h/2, neighbor.point.y + h/2
                        );
                    }
                }
                
                // Draw the point itself slightly larger
                drawPoint(neighbor.point.x, neighbor.point.y, neighbor.point.shape, neighbor.point.color, 12);
            }
            
            // Continue expanding only if we don't have k neighbors yet
            if (!hasKNeighbors) {
                animationRadius += ANIMATION_SPEED;
            }
        }

        function mousePressed() {
            // Check if click is within canvas
            if (mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height) {
                animatingPoint = { x: mouseX, y: mouseY };
                animationRadius = 0;
                nearestNeighbors = [];
            }
        }
    </script>
</body>
</html>
